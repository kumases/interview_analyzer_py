# --- Appクラスの__init__メソッドの変更 ---
# 役割: UiStateManagerのインスタンスを作成し、UI要素への参照を渡します。
#       既存の初期化コードの一部として追加されます。
# 変更前:
#         self.is_path_entry_dnd_registered = True # path_entryがDND登録されているかどうかのフラグを追加
# 変更後:
#         self.is_path_entry_dnd_registered = True # path_entryがDND登録されているかどうかのフラグを追加
#         # UiStateManagerのインスタンスを作成
#         self.ui_manager = UiStateManager(self)


# --- 変更後の on_mode_change 関数 ---
# 役割: モード選択に応じてUIの状態をUiStateManager経由で設定します。
#       UI要素の直接操作はUiStateManagerに移管されます。
    def on_mode_change(self):
        selected_mode = self.mode_variable.get()
        if selected_mode == "qa":
            # AI対話モードの初期UI状態を設定
            self.ui_manager.set_mode_qa_initial_state()
        else:
            # 通常モードのUI状態を設定
            self.ui_manager.set_mode_normal_state()

        # ログエリアをクリア (これはUI状態管理とは独立しているため残します)
        self.log_textbox.configure(state="normal")
        self.log_textbox.delete("1.0", "end")
        self.log_textbox.configure(state="disabled")


# --- 変更後の _prepare_qa_session 関数 ---
# 役割: AI対話モードの準備が完了した際に、UIの状態をUiStateManager経由で設定します。
#       AI対話関連UIを活性化し、その他のUIを非活性化します。
    def _prepare_qa_session(self):
        print("DEBUG: _prepare_qa_session called.")
        self.log("AI対話モードの準備を開始します...")
        
        # backend_logicからデータを読み込み、件数とチャットセッションを取得
        initial_context, interview_count, daily_report_count, message, chat_session = backend_logic.prepare_qa_data()
        
        if initial_context is None:
            self.log(f"エラー: {message}")
            self.stop_spinner()
            self.run_button.configure(state="normal") # エラー時はAI対話開始ボタンを活性化
            return

        self.qa_context = initial_context # 初期コンテキストをインスタンス変数に保存
        self.chat_session = chat_session # チャットセッションをインスタンス変数に保存

        # 読み込み件数をログに表示
        self.log(f"面談要約データ {interview_count}件、日報分析データ {daily_report_count}件を読み込みました。")
        self.log("質問を入力して「送信」ボタンを押してください。")
        
        self.in_qa_session = True # AI対話セッション開始
        self.stop_spinner() # スピナーを停止

        # UIの状態をUiStateManager経由で設定
        self.ui_manager.set_qa_active_state()


# --- 変更後の send_qa_message 関数 ---
# 役割: 質問送信時、UIの状態をUiStateManager経由で設定します。
#       処理中はUIを無効化します。
    def send_qa_message(self):
        question = self.qa_input_entry.get()
        if not question:
            self.log("質問を入力してください。")
            return
        
        self.log(f"あなた: {question}")
        self.qa_input_entry.delete(0, "end") # 入力フィールドをクリア
        
        # UIの状態をUiStateManager経由で設定 (処理中状態)
        self.ui_manager.set_processing_state()
        self.start_spinner()
        
        # AIへの質問をスレッドで実行
        thread = threading.Thread(target=self._send_qa_message_backend, args=(question,))
        thread.start()


# --- 変更後の _send_qa_message_backend 関数 ---
# 役割: AIからの応答後、UIの状態をUiStateManager経由で設定します。
#       AI対話関連UIを活性化します。
    def _send_qa_message_backend(self, question):
        try:
            # backend_logicのask_question_to_aiを呼び出す
            # chat_sessionとqa_contextを渡す
            response_message = backend_logic.ask_question_to_ai(question, self.chat_session, self.qa_context)
            self.log(response_message)
        except Exception as e:
            error_message = f"AIとの対話中にエラーが発生しました: {e}\n{traceback.format_exc()}"
            self.log(error_message)
            messagebox.showerror("エラー", "AIとの対話中にエラーが発生しました。ログを確認してください。")
        finally:
            self.stop_spinner()
            # UIの状態をUiStateManager経由で設定 (AI対話活性状態)
            self.ui_manager.set_qa_active_state()


# --- 変更後の end_qa_session 関数 ---
# 役割: AI対話セッション終了時、UIの状態をUiStateManager経由で設定します。
#       AI対話関連UIと削除関連UIを非活性化し、通常モードのUI状態に戻します。
    def end_qa_session(self):
        self.stop_spinner()
        
        # UIの状態をUiStateManager経由で設定 (AI対話非活性状態)
        self.ui_manager.set_qa_inactive_state()

        self.qa_context = None # コンテキストをクリア
        self.chat_session = None # チャットセッションをクリア
        self.log("AI対話セッションを終了します。")
        self.in_qa_session = False # AI対話セッション終了
        
        # UIを初期状態に戻す (on_mode_changeが通常モードのUI状態を設定します)
        self.on_mode_change()


# --- 変更後の update_delete_combobox 関数 ---
# 役割: 削除対象データ取得開始時、UIの状態をUiStateManager経由で設定します。
#       削除関連UIを無効化します。
    def update_delete_combobox(self):
        self.log("削除対象データを取得中...")
        # UIの状態をUiStateManager経由で設定 (削除関連UI非活性状態)
        self.ui_manager.set_delete_ui_inactive()
        self.start_spinner()
        thread = threading.Thread(target=self._update_delete_combobox_backend)
        thread.start()


# --- 変更後の _update_delete_combobox_backend 関数 ---
# 役割: 削除対象データ取得完了後、UIの状態をUiStateManager経由で設定します。
#       削除関連UIを活性化します。
    def _update_delete_combobox_backend(self):
        self.log("DEBUG: _update_delete_combobox_backend called.")
        deletable_items, _, _ = backend_logic.run_backend_process(mode="get_delete_list")
        self.log(f"DEBUG: deletable_items from backend: {deletable_items}")
        if deletable_items and isinstance(deletable_items, list):
            self.after(0, lambda: self.delete_combobox.configure(values=deletable_items))
            self.after(0, lambda: self.delete_combobox.set("削除対象を選択してください..."))
            self.log(f"{len(deletable_items)}件の削除対象データを取得しました。")
        else:
            self.log("削除対象データが見つかりませんでした。")
            self.after(0, lambda: self.delete_combobox.configure(values=["削除対象なし"]))
            self.after(0, lambda: self.delete_combobox.set("削除対象なし"))
        
        self.stop_spinner()
        # UIの状態をUiStateManager経由で設定 (削除関連UI活性状態)
        self.ui_manager.set_delete_ui_active()


# --- 変更後の execute_delete 関数 ---
# 役割: 削除実行時、UIの状態をUiStateManager経由で設定します。
#       削除関連UIを無効化します。
    def execute_delete(self):
        selected_item = self.delete_combobox.get()
        if selected_item == "削除対象を選択してください..." or selected_item == "削除対象なし":
            self.log("削除対象を選択してください。")
            return
        
        confirm = messagebox.askyesno("確認", f"本当に以下のデータを削除しますか？\n\n{selected_item}")
        if confirm:
            self.log(f"削除を実行中: {selected_item}")
            # UIの状態をUiStateManager経由で設定 (削除関連UI非活性状態)
            self.ui_manager.set_delete_ui_inactive()
            self.start_spinner()
            thread = threading.Thread(target=self._execute_delete_backend, args=(selected_item,))
            thread.start()
        else:
            self.log("削除がキャンセルされました。")


# --- 変更後の _execute_delete_backend 関数 ---
# 役割: 削除処理完了後、UIの状態をUiStateManager経由で設定します。
#       削除関連UIを活性化します。
    def _execute_delete_backend(self, selected_item):
        try:
            message, _, _ = backend_logic.run_backend_process(mode="execute_delete", input_path=selected_item)
            self.log(message)
            self.update_delete_combobox() # 削除後にリストを更新
        except Exception as e:
            error_message = f"削除処理中にエラーが発生しました: {e}\n{traceback.format_exc()}"
            self.log(error_message)
            messagebox.showerror("エラー", "削除処理中にエラーが発生しました。ログを確認してください。")
        finally:
            self.stop_spinner()
            # UIの状態をUiStateManager経由で設定 (削除関連UI活性状態)
            self.ui_manager.set_delete_ui_active()


# --- 変更後の start_analysis 関数 ---
# 役割: 分析開始時、UIの状態をUiStateManager経由で設定します。
#       処理中はUIを無効化します。
    def start_analysis(self):
        print("DEBUG: start_analysis called.")
        mode = self.mode_variable.get()
        path = os.path.normpath(self.path_entry.get())

        # UIの状態をUiStateManager経由で設定 (処理中状態)
        self.ui_manager.set_processing_state()
        self.start_spinner()

        # ログエリアをクリア (これはUI状態管理とは独立しているため残します)
        self.log_textbox.configure(state="normal")
        self.log_textbox.delete("1.0", "end")
        self.log_textbox.configure(state="disabled")

        # 結果ファイル表示ボタンを非表示に
        self.result_file_button.grid_remove()
        self.result_file_path = None

        # 結果フォルダ表示ボタンを非表示に
        self.result_folder_button.grid_remove()
        self.result_folder_path = None

        # その他のモードは既存の処理
        thread = threading.Thread(target=self.run_backend, args=(mode, path, None, None))
        thread.start()


# --- 変更後の start_qa_session_flow 関数 ---
# 役割: AI対話セッション開始フロー時、UIの状態をUiStateManager経由で設定します。
#       処理中はUIを無効化します。
    def start_qa_session_flow(self):
        print("DEBUG: start_qa_session_flow called.")
        # UIの状態をUiStateManager経由で設定 (処理中状態)
        self.ui_manager.set_processing_state()
        self.start_spinner()

        # 結果フォルダ表示ボタンを非表示に (これはUI状態管理とは独立しているため残します)
        self.result_folder_button.grid_remove()
        self.result_folder_path = None

        thread = threading.Thread(target=self._prepare_qa_session)
        thread.start()


# --- 変更後の run_backend 関数 ---
# 役割: バックエンド処理完了後、またはエラー発生後、UIの状態をUiStateManager経由で設定します。
    def run_backend(self, mode, path, question, context):
        try:
            self.log(f"バックエンド処理開始: モード={mode}, パス={path if path else 'N/A'}")
            message, saved_paths = backend_logic.run_backend_process(mode, path, question, context)
            self.log(message)
            if saved_paths:
                if mode == "interview":
                    # 面談分析の場合、結果ファイル表示ボタンを表示
                    self.result_file_path = saved_paths[0] # 最初のファイルパスを保存
                    self.result_file_button.configure(text=f"結果ファイルを開く: {os.path.basename(self.result_file_path)}")
                    self.result_file_button.grid()
                    # 結果フォルダ表示ボタンも表示
                    self.result_folder_path = os.path.dirname(self.result_file_path)
                    self.result_folder_button.configure(text=f"結果フォルダを開く: {os.path.basename(self.result_folder_path)}")
                    self.result_folder_button.grid()
                elif mode == "daily_report":
                    # 日報分析の場合、結果フォルダ表示ボタンを表示
                    if saved_paths: # saved_pathsが空でないことを確認
                        self.result_folder_path = os.path.dirname(saved_paths[0]) # 最初のファイルパスのディレクトリを保存
                        self.result_folder_button.configure(text=f"結果フォルダを開く: {os.path.basename(self.result_folder_path)}")
                        self.result_folder_button.grid()
            self.stop_spinner()
            # 処理完了後、UIをアイドル状態に設定
            self.ui_manager.set_idle_state()
            
        except Exception as e:
            error_message = f"バックエンド処理中にエラーが発生しました: {e}\n{traceback.format_exc()}"
            self.log(error_message)
            messagebox.showerror("エラー", "バックエンド処理中にエラーが発生しました。ログを確認してください。")
            self.stop_spinner()
            # エラー発生後、UIをアイドル状態に設定
            self.ui_manager.set_idle_state()